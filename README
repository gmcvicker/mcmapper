mcmapper - software for unbiased read mapping
======================================================================


Introduction
------------
This repository contains software for unbiased read-mapping. By
"unbiased", we mean that known SNPs are taken into account when
mapping reads to the genome and when computing mappability
(i.e. determining whether reads from a genomic location would map
uniquely back to the genome).

This softare is especially useful when performing tests for
allele-specific expression. These tests tend to be very sensitive to
mapping bias, which cannot be overcome simply by masking SNPs and
using a conventional read mapper (see Degner et al. 2009).

To perform unbiased read-mapping, perform the following steps,
described in detail below:
  1. Mark-up a reference genome with known SNPs
  2. Build a seed index for the marked-up reference genome
  3. Calculate the mappability of each position in the genome
  4. Map reads to the genome
  5. Merge mapped read files, sort and discard duplicates (if desired)
  6. Filter mapped reads for mappability and indel overlap etc.



0. Compiling / Installing
-------------------------
- depends on genome library
- download from git
- compile
- add to LD_LIBRARY_PATH



1. Marking up reference genome with SNPs
-----------------------------------------
mark_fasta_SNPs.py

Markup a genome sequence with ambiguity characters representing the
locations and alleles of every SNP. This script is currently written
in python and has hardcoded paths to HDF5 files containing the hg18
genome sequence and the locations of all 1000 genomes phase1 SNPs. An
output directory must be provided to the script. The script writes a
single ambiguity-code containing fasta file for each
chromosome. Currently indels are ignored.

This program should probably be re-written to directly use 
FASTA files and a SNP list from 1000 genomes or dbSNP.

Example:
  python mark_fasta_SNPs.py ~/data/hg18/seq_with_snps



2. Builing a seed index
-----------------------
build_seed_index

Create a binary file that contains genomic positions of seed
matches. This only needs to be done once for a seed of a given length
(and a given genome with SNPs). For example, the following command
builds an index table of 13 bp seeds:

Exmaple:
  ./build_seed_index 13 chromInfo.txt seed_idx.13.gz ~/data/hg18/seq_with_snps/chr*.fa.gz



3. Calculating mappability
--------------------------
calc_mapping_uniqueness

Calculate mapping uniqueness of reads starting at every possible
genomic position using the program calc_mapping_uniqueness. This needs
to be done once for each read length. This program writes a single
wiggle file per chromosome containing the following integer codes for
reads starting at each position:

 0 - does not map (contains N, or overhangs chromosome end)
 1 - maps uniquely
 2 - maps to multiple locations

This program takes into account SNPs (identified by ambiguity codes)
and will attempt to map all combinations of alleles. Sometimes one
allele will map unquely, but the other allele will map to multiple
locations. In this case, the read is flagged as mapping to multiple
locations.

The program arguments are:
  1  path to seed table created by build_seed_index
  2  path to chromInfo.txt file giving chromosome names and lengths
  3  length of reads in bp
  4  number of allowed mismatches (0 or 1)
  5  output directory to write wiggle files to
  6+ fasta files containing genome sequence with 
     ambiguity codes representing SNPs

Example:
  ./calc_mapping_uniqueness /data/share/10_IND_v2/mapper/input_files/seed_idx.13bp.hg18.gz /data/share/10_IND_v2/mapper/input_files/chromInfo.hg18.txt 36 0 /data/share/10_IND_v2/mapper/mappability/36bp/0_mismatch /data/share/10_IND_v2/mapper/input_files/hg18_with_snps/chr*.fa.gz


load_mapping_uniqueness.sh

Convert the mapping uniqueness wiggle files to HDF5 format.  Edit the
script load_mapping_uniqueness.sh, which calls the create_track.py
script that actually creates the HDF5 files.


4. Mapping Reads
----------------
map_fastq

Map all reads in a fastq file to the genome. This program assigns each
read the following mapping code:

  0 - does not map
  1 - maps uniquely
  2 - maps to multiple locations

Reads are written to separate output files, depending on their
status. Unmapped reads are written to 'unmapped.txt.gz',
multiply-mapping reads are written to 'multi_mapped.txt.gz' and
uniquely mapping reads are written to a single file per chromosome
(e.g. chr1.mapped.txt.gz for reads that map uniquely to chr1).

A read is first mapped without allowing mismatches. If the read fails
to map without mismatches, a second attempt is made to map the read,
allowing a single mismatch. Known SNPs are taken into account when
mapping--bases that match the reference or non-reference allele are
not considered mismatches. Single mismatches are allowed (if the read
initially fails to map) to avoid mapping bias introduced by unknown
SNPs (e.g. private variants). Unfortunately unknown indels can still
result in occasionally biased mapping. Reads that contain Ns are not
mapped.

The program arguments are:
  1  path to seed table created by build_seed_index
  2  path to chromInfo.txt file giving chromosome names and lengths
  3  path to fastq file (may be gzipped)
  4  path to output directory
  5+ fasta files containing genome sequence with 
     ambiguity codes representing SNPs

If a 13bp seed table is used, this program needs about 20Gb of memory
to map reads to the human genome.

The output files have one read per line with the following
space-delimited columns. Reads are reverse complemented if they mapped
to the reverse strand so that the sequence can always be directly
compared to the forward strand of the genome.
  1 - read sequence (reverse complemented if read mapped to - strand)
  2 - chromosome name (or . if did not map)
  3 - read start position
  4 - strand (+, -); for (-) strand reads, read has been reverse complemented
  5 - mapping code (0, 1, 2) for unmapped, unique, multiple
  6 - number of mismatches (0 or 1)


Example:
  ./map_fastq seed_idx.13.gz chromInfo.txt H3K4me1_18508.fastq.gz out/ ~/data/hg18/seq_with_snps/chr*.fa.gz


To run a lot of mapping jobs on the cluster use a submission script
like the one here: sh/map_reads.sh



5. Merging, sorting and removing duplicate mapped reads
-------------------------------------------------------
merge_sort_rmdup.sh

This script (written by Bryce):
  - merges lanes of mapped reads
  - sorts mapped reads
  - filters duplicate mapped reads



6. Filtering mapped reads
-------------------------
filter_mappability_indels.py

Filter reads that:
  - map to location where at least one allele maps to multiple locations
  - overlap indels
  - overlap SNPs with 'reference allele' that does not match reference

Can run this script on cluster using: submit_filter_mappability_indels.sh


